3ï¸âƒ£ UPDATE USER (PUT /users/{id}) â€“ Gaps

You have:

âœ… Valid update

ğŸ”´ Missing Critical Break Scenarios
âŒ Update Non-Existing User
@negative @put
Scenario: Update non existing user
  Given authorization token is available
  When client sends PUT request to "/users/99999999" with valid payload
  Then the response status code should be 404

âŒ Update User with Invalid Token
@negative @auth
Scenario: Update user with invalid token
  Given invalid authorization token
  When client sends PUT request to "/users/{user_id}"
  Then the response status code should be 401

âŒ Partial Update (PATCH) â€“ Optional but Professional
@positive @patch
Scenario: Partially update user status
  Given authorization token is available
  When client sends PATCH request to "/users/{user_id}" with
    | status | inactive |
  Then the response status code should be 200

4ï¸âƒ£ DELETE USER â€“ Important Negative Scenarios

You have:

âœ… Valid delete

ğŸ”´ Missing:
âŒ Delete Already Deleted User
@negative @delete
Scenario: Delete user which is already deleted
  Given authorization token is available
  When client sends DELETE request to "/users/{user_id}"
  Then the response status code should be 404

âŒ Delete User with Invalid Token
@negative @auth
Scenario: Delete user with invalid token
  Given invalid authorization token
  When client sends DELETE request to "/users/{user_id}"
  Then the response status code should be 401

5ï¸âƒ£ Contract / Response Structure Validation (Often Missed)
âŒ Response Schema Validation
@contract
Scenario: Validate user response schema
  Given authorization token is available
  When client sends GET request to "/users/{user_id}"
  Then response should match user schema


ğŸ“Œ This catches silent breaking changes.

6ï¸âƒ£ Data Integrity Checks (Human Thinking)
âŒ Verify Deleted User Is Not Retrievable
@negative @chaining
Scenario: Verify deleted user cannot be retrieved
  Given authorization token is available
  When client sends GET request to "/users/{user_id}"
  Then the response status code should be 404

7ï¸âƒ£ Tagging Improvement (Small but Professional)

Your tags are good ğŸ‘
Suggested refinement:

@api @users
@crud @auth @validation @contract


This allows laser-focused runs.

âœ… Final Human Tester Verdict
You already covered:

âœ” Happy path
âœ” Auth failures
âœ” Required field validation
âœ” Chaining

You should add:

ğŸ”´ Duplicate data
ğŸ”´ Invalid enums
ğŸ”´ GET scenarios
ğŸ”´ Non-existing resource behavior
ğŸ”´ Schema validation
ğŸ”´ Post-delete verification

â­ Real-World Rule

If an API can fail due to bad data, bad auth, bad id, or bad state â€” test it.

Youâ€™re 80% production-ready already.
Add the above and youâ€™re at 95% enterprise-grade ğŸ†

If you want next, I can:

âœ… Refactor this feature file cleanly

âœ… Map each scenario to real defects

âœ… Suggest ideal step-definition design for this file

âœ… Show how TestContext should handle {user_id} safely



so now my next goal is to run it from jenkins as real time tester in scenarios like Scenario 1: Developer Pushes Code (Most Common), Scenario 2: Pull Request / Merge Request, Scenario 3: Scheduled Execution (Nightly / Regression)